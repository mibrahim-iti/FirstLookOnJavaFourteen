/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.mibrahim.javafourteen;

import static org.junit.Assert.assertEquals;
import static org.junit.Assert.assertFalse;
import static org.junit.Assert.assertNotNull;
import static org.junit.Assert.assertNull;
import static org.junit.Assert.assertSame;
import static org.junit.Assert.assertTrue;

import java.lang.annotation.Annotation;
import java.time.LocalDate;
import java.util.Map;

import org.junit.Test;

import com.mibrahim.javafourteen.record.Annotation.OnFieldAnnotation;
import com.mibrahim.javafourteen.record.Annotation.RepeatableAnnotation;
import com.mibrahim.javafourteen.record.GenericRecord;
import com.mibrahim.javafourteen.record.UserInOldWay;
import com.mibrahim.javafourteen.record.UserRecordAcceptAnnotation;
import com.mibrahim.javafourteen.record.UserRecordImplementsInterface;
import com.mibrahim.javafourteen.record.UserRecordWithCompactConstructor;
import com.mibrahim.javafourteen.record.UserRecordWithDefaultConstructor;
import com.mibrahim.javafourteen.record.UserRecordWithNormalConstructor;
import com.mibrahim.javafourteen.record.UserRecordWithOverloadConstructor;

/**
 * A test class just to test methods quickly and not a production tests
 * 
 * So it's not follow a good examples of writing tests
 * 
 * For example i am doing a combination of sucess and failer tests under one test case which shouldn't be a case for a production tests
 * and also i am not using SuiteClasses to categories or group related tests
 * 
 * and even it doesn't cover all possible test cases
 * 
 * @author Mohamed-Ibrahim
 *
 */
public class RecordTest {

	LocalDate birthDate = LocalDate.of(1990, 1, 1);;

	@Test
	public void testOldWayBeforeRecord() {
		UserInOldWay userInOldWay = new UserInOldWay();
		assertNotNull(userInOldWay.getFirstname());

		userInOldWay = new UserInOldWay("Mohamed", "Ibrahim");
		assertEquals("Failure - strings are not equal", "Mohamed", userInOldWay.getFirstname());
	}

	@Test
	public void testRecordWithDefaultConstructor() {
		UserRecordWithDefaultConstructor user = new UserRecordWithDefaultConstructor("Mohamed", "Ibrahim");
		assertEquals("Failure - strings are not equal", "Mohamed", user.firstname());

		user = new UserRecordWithDefaultConstructor(null, "Ibrahim");
		assertEquals("Failure - strings are not equal", null, user.firstname());

		UserRecordWithDefaultConstructor.birthDate = birthDate;
		assertTrue(user.getAge() > 25);
		assertTrue(UserRecordWithDefaultConstructor.getAgeFromStaticMethod() > 25);
	}

	@Test
	public void testRecordWithNormalConstructor() {
		UserRecordWithNormalConstructor user = new UserRecordWithNormalConstructor("Mohamed", "Ibrahim");
		assertEquals("Failure - strings are not equal", "Mohamed", user.firstname());

		UserRecordWithNormalConstructor.birthDate = birthDate;
		assertTrue(user.getAge() > 25);
		assertTrue(UserRecordWithNormalConstructor.getAgeFromStaticMethod() > 25);
	}

	@Test(expected = IllegalArgumentException.class)
	public void testPassingFirstnameWithNullValueInRecordWithNormalOverrittenConstructor() {
		new UserRecordWithNormalConstructor(null, "Ibrahim");
	}

	@Test
	public void testRecordWithCompactConstructor() {
		UserRecordWithCompactConstructor user = new UserRecordWithCompactConstructor("Mohamed", "Ibrahim");
		assertEquals("Failure - strings are not equal", "Mohamed", user.firstname());

		UserRecordWithCompactConstructor.birthDate = birthDate;
		assertTrue(user.getAge() > 25);
		assertTrue(UserRecordWithCompactConstructor.getAgeFromStaticMethod() > 25);
	}

	@Test(expected = IllegalArgumentException.class)
	public void testPassingFirstnameWithNullValueInRecordWithCompactOverrittenConstructor() {
		new UserRecordWithCompactConstructor(null, "Ibrahim");
	}

	@Test
	public void testRecordImplementsInterface() {
		UserRecordImplementsInterface user = new UserRecordImplementsInterface("Mohamed", "Ibrahim");
		assertEquals("Failure - strings are not equal",
				String.format("{\"firstname\": %s, \"lastname\": %s}", user.firstname(), user.lastname()),
				user.asJson());
	}

	@Test
	public void testRecordOverloadingConstructor() {
		// Using one parameter overloaded constructor
		UserRecordWithOverloadConstructor user = new UserRecordWithOverloadConstructor("Mohamed Ibrahim");
		assertEquals("Failure - strings are not equal", "Mohamed", user.firstname());

		// Using two parameters default constructor
		user = new UserRecordWithOverloadConstructor("Mohamed", "Ibrahim");
		assertEquals("Failure - strings are not equal", "Mohamed", user.firstname());
	}

	@Test
	public void testRecordAcceptAnnotation() throws Exception {
		Map<String, Annotation> annotationsMap = UserRecordAcceptAnnotation.recordMethod();
		assertNotNull(annotationsMap);
		assertFalse(annotationsMap.isEmpty());

		assertTrue(annotationsMap.get("recordMethod") instanceof RepeatableAnnotation);
		assertNull(annotationsMap.get("firstname"));
		assertTrue(annotationsMap.get("lastname") instanceof OnFieldAnnotation);
	}

	@Test
	public void testRecordWithGeneric() throws Exception {
		// Using a String
		GenericRecord<String> stringParamRec = new GenericRecord<>("Mohamed", "Ibrahim");
		assertEquals("Failure - strings are not equal", "Mohamed", stringParamRec.firstParam());
		assertEquals("Failure - strings are not equal", "Ibrahim", stringParamRec.secondParam());

		// Using Integer
		GenericRecord<Integer> intParamRec = new GenericRecord<>(10, 20);
		assertSame(10, intParamRec.firstParam());
		assertSame(20, intParamRec.secondParam());
	}
}
